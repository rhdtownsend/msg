! Module   : tools_utils_m.fypp
! Purpose  : support routines for tools
!
! Copyright 2021-2023 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module tools_utils_m

   ! Uses

   use forum_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Interfaces

   interface parse_name_value
      module procedure parse_name_value_r_
      module procedure parse_name_value_a_
   end interface parse_name_value

   interface parse_name_values
      module procedure parse_name_values_r_r_
   end interface parse_name_values

   interface parse_values
      module procedure parse_values_r_r_
      module procedure parse_values_r_i_
   end interface parse_values

   ! Access specifiers

   private

   public :: append_string
   public :: parse_name_value
   public :: parse_name_values
   public :: parse_values

   ! Routines

contains

   subroutine append_string(strings, string)

      character(:), intent(inout), allocatable :: strings(:)
      character(*), intent(in)                 :: string

      integer                   :: n
      integer                   :: strings_len
      character(:), allocatable :: strings_new(:)

      ! Append a string to the list of strings

      if (ALLOCATED(strings)) then

         n = SIZE(strings)

         strings_len = MAX(LEN(strings), LEN(string))

         allocate(character(strings_len)::strings_new(n+1))

         strings_new(:n) = strings
         strings_new(n+1) = string

         call MOVE_ALLOC(strings_new, strings)

      else

         strings_len = LEN(string)

         allocate(character(strings_len)::strings(1))

         strings(1) = string

      end if

      ! Finish

      return

   end subroutine append_string

   !****

   subroutine parse_name_value_r_(name_value, name, value)

      character(*), intent(in)               :: name_value
      character(:), allocatable, intent(out) :: name
      real(RD), intent(out)                  :: value

      integer :: i
      integer :: len

      ! Parse the colon-separated name-value pair into a name and a value

      i = INDEX(name_value, ':')

      if (i > 1) then

         len = LEN_TRIM(name_value)

         if (i < len) then
            name = name_value(1:i-1)
            read(name_value(i+1:len), *) value
         else
            @:ABORT('missing value in name-value pair "'//TRIM(name_value)//'"')
         end if

      elseif (i == 1) then

         @:ABORT('missing name in name-value pair "'//TRIM(name_value)//'"')

      else

         @:ABORT('missing colon in name-value pair "'//TRIM(name_value)//'"')

      end if

      ! Finish

      return

   end subroutine parse_name_value_r_

   !****

   subroutine parse_name_value_a_(name_value, name, value)

      character(*), intent(in)               :: name_value
      character(:), allocatable, intent(out) :: name
      character(:), allocatable, intent(out) :: value

      integer :: i
      integer :: len

      ! Parse the colon-separated name-value pair into a name and a value

      i = INDEX(name_value, ':')

      if (i > 1) then

         len = LEN_TRIM(name_value)

         if (i < len) then
            name = name_value(1:i-1)
            value = name_value(i+1:len)
         else
            @:ABORT('missing value in name-value pair "'//TRIM(name_value)//'"')
         end if

      elseif (i == 1) then

         @:ABORT('missing name in name-value pair "'//TRIM(name_value)//'"')

      else

         @:ABORT('missing colon in name-value pair "'//TRIM(name_value)//'"')

      end if

      ! Finish

      return

   end subroutine parse_name_value_a_

   !****

   subroutine parse_name_values_r_r_(name_values, name, value_a, value_b)

      character(*), intent(in)               :: name_values
      character(:), allocatable, intent(out) :: name
      real(RD), intent(out)                  :: value_a
      real(RD), intent(out)                  :: value_b

      character(:), allocatable :: values

      ! Parse the colon-separated name-values triplet into a name and
      ! a pair of values

      call parse_name_value(name_values, name, values)

      call parse_values(values, value_a, value_b)

      ! Finish

      return

   end subroutine parse_name_values_r_r_

   !****

   subroutine parse_values_r_r_(values, value_a, value_b)

      character(*), intent(in) :: values
      real(RD), intent(out)    :: value_a
      real(RD), intent(out)    :: value_b

      integer :: i
      integer :: len

      ! Parse the colon-separated values pair into a pair of values

      i = INDEX(values, ':')

      if (i > 1) then

         len = LEN_TRIM(values)

         if (i < len) then
            read(values(1:i-1), *) value_a
            read(values(i+1:len), *) value_b
         else
            @:ABORT('missing second value in value pair "'//TRIM(values)//'"')
         end if

      elseif (i == 1) then

         @:ABORT('missing first value in value pair "'//TRIM(values)//'"')

      else

         @:ABORT('missing colon in values pair "'//TRIM(values)//'"')

      end if

      ! Finish

      return

   end subroutine parse_values_r_r_

   !****

   subroutine parse_values_r_i_(values, value_a, value_b)

      character(*), intent(in) :: values
      real(RD), intent(out)    :: value_a
      integer, intent(out)     :: value_b

      integer :: i
      integer :: len

      ! Parse the colon-separated values pair into a pair of values

      i = INDEX(values, ':')

      if (i > 1) then

         len = LEN_TRIM(values)

         if (i < len) then
            read(values(1:i-1), *) value_a
            read(values(i+1:len), *) value_b
         else
            @:ABORT('missing second value in value pair "'//TRIM(values)//'"')
         end if

      elseif (i == 1) then

         @:ABORT('missing first value in value pair "'//TRIM(values)//'"')

      else

         @:ABORT('missing colon in values pair "'//TRIM(values)//'"')

      end if

      ! Finish

      return

   end subroutine parse_values_r_i_

end module tools_utils_m
