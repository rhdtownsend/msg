! Module   : tools_utils_m.fypp
! Purpose  : Support routines for tools
!
! Copyright 2021-2025 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module tools_utils_m

   ! Uses

   use forum_m

   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Interfaces

   interface parse_value
      module procedure parse_value_i_
      module procedure parse_value_r_
   end interface parse_value

   interface parse_values
      module procedure parse_values_i_
      module procedure parse_values_r_
      module procedure parse_values_a_
   end interface parse_values

   interface parse_name_value
      module procedure parse_name_value_r_
      module procedure parse_name_value_i_
   end interface parse_name_value

   interface parse_name_values
      module procedure parse_name_values_r_
      module procedure parse_name_values_i_
   end interface parse_name_values

   ! Access specifiers

   private

   public :: append_string
   public :: parse_value
   public :: parse_values
   public :: parse_name_value
   public :: parse_name_values

   ! Routines

contains

   subroutine append_string(strings, string)

      character(:), intent(inout), allocatable :: strings(:)
      character(*), intent(in)                 :: string

      integer                   :: n
      integer                   :: strings_len
      character(:), allocatable :: strings_new(:)

      ! Append a string to the list of strings

      if (ALLOCATED(strings)) then

         n = SIZE(strings)

         strings_len = MAX(LEN(strings), LEN(string))

         allocate(character(strings_len)::strings_new(n+1))

         strings_new(:n) = strings
         strings_new(n+1) = string

         call MOVE_ALLOC(strings_new, strings)

      else

         strings_len = LEN(string)

         allocate(character(strings_len)::strings(1))

         strings(1) = string

      end if

      ! Finish

      return

   end subroutine append_string

   !****

   #:for type, suffix in (('integer', 'i'), ('real(RD)', 'r'))

      subroutine parse_value_${suffix}$_(string, value, stat)

         character(*), intent(in)           :: string
         ${type}$, allocatable, intent(out) :: value
         integer, intent(out), optional     :: stat

         integer :: iostat

         ! Parse the string into a value

         parse_block: block

            allocate(value)

            read(string, FMT=*, IOSTAT=iostat) value
            if (iostat /= 0) exit parse_block

            return

         end block parse_block

         if (PRESENT(stat)) then
            stat = STAT_INVALID_ARGUMENT
         else
            @:ABORT('invalid argument')
         end if

         ! Finish

         return

      end subroutine parse_value_${suffix}$_

   !****

      subroutine parse_values_${suffix}$_(string, value_a, value_b, stat, delim)

         character(*), intent(in)           :: string
         ${type}$, allocatable, intent(out) :: value_a
         ${type}$, allocatable, intent(out) :: value_b
         integer, intent(out), optional     :: stat
         character(*), intent(in), optional :: delim

         character(:), allocatable :: value_a_str
         character(:), allocatable :: value_b_str
         integer                   :: iostat

         ! Parse the string into a pair of values, with delim as the
         ! separator

         call parse_values(string, value_a_str, value_b_str, stat, delim)

         parse_block: block

            allocate(value_a)

            read(value_a_str, FMT=*, IOSTAT=iostat) value_a
            if (iostat /= 0) exit parse_block

            allocate(value_b)

            read(value_b_str, FMT=*, IOSTAT=iostat) value_b
            if (iostat /= 0) exit parse_block

            return

         end block parse_block

         if (PRESENT(stat)) then
            stat = STAT_INVALID_ARGUMENT
         else
            @:ABORT('invalid argument')
         end if

         ! Finish

         return

      end subroutine parse_values_${suffix}$_

      !****

      subroutine parse_name_value_${suffix}$_(string, name, value, stat, delim)

         character(*), intent(in)               :: string
         character(:), allocatable, intent(out) :: name
         ${type}$, allocatable, intent(out)     :: value
         integer, intent(out), optional         :: stat
         character(*), intent(in), optional     :: delim

         character(:), allocatable :: value_str

         ! Parse the string into a name and a value, with delim as the
         ! separator

         call parse_values(string, name, value_str, stat, delim)
         if (PRESENT(stat)) then
            if (stat /= 0) return
         end if

         allocate(value)

         call parse_value(value_str, value, stat)

         ! Finish

         return

      end subroutine parse_name_value_${suffix}$_

      !****

      subroutine parse_name_values_${suffix}$_(string, name, value_a, value_b, stat, delim)

         character(*), intent(in)               :: string
         character(:), allocatable, intent(out) :: name
         ${type}$, allocatable, intent(out)     :: value_a
         ${type}$, allocatable, intent(out)     :: value_b
         integer, intent(out), optional         :: stat
         character(*), intent(in), optional     :: delim

         character(:), allocatable :: values_str

         ! Parse the string into a name and a pair of values, with delim
         ! as the separator

         call parse_values(string, name, values_str, stat, delim)
         if (PRESENT(stat)) then
            if (stat /= 0) return
         end if

         call parse_values(values_str, value_a, value_b, stat, delim)

         ! Finish

         return

      end subroutine parse_name_values_${suffix}$_

   #:endfor

   !****

   subroutine parse_values_a_(string, value_a, value_b, stat, delim)

      character(*), intent(in)               :: string
      character(:), allocatable, intent(out) :: value_a
      character(:), allocatable, intent(out) :: value_b
      integer, intent(out), optional         :: stat
      character(*), intent(in), optional     :: delim

      character(:), allocatable :: delim_

      if (PRESENT(delim)) then
         delim_ = delim
      else
         delim_ = ':'
      end if

      ! Parse the string into a pair of values, with delim as the
      ! separator

      value_b = string
      call split(value_b, value_a, delim_)

      if (PRESENT(stat)) stat = STAT_OK

      ! Finish

      return

   end subroutine parse_values_a_

end module tools_utils_m
