! Module   : synspec_to_specint
! Purpose  : create a specint file from a synspec file
!
! Copyright 2021-2025 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

program synspec_to_specint

   ! Uses

   use forum_m
   use math_m
   use msg_m

   use tools_utils_m

   use ISO_FORTRAN_ENV
   use IEEE_ARITHMETIC

   ! No implicit typing

   implicit none (type, external)

   ! Variables

   character(:), allocatable :: synspec_file_name
   character(:), allocatable :: specint_file_name
   character(:), allocatable :: file_type
   character(:), allocatable :: limb_law
   real(RD), allocatable     :: mu_min
   integer, allocatable      :: n_mu
   character(:), allocatable :: labels(:)

   type(arg_parser_t)        :: arg_parser
   type(limb_specint_t)      :: specint
   type(hdf5io_t)            :: hdf5io
   type(hdf5io_t)            :: hdf5io_labels
   integer                   :: j
   character(:), allocatable :: name
   real(RD), allocatable     :: value
   integer                   :: stat

   ! Parse command-line arguments

   file_type = 'flux'
   limb_law = 'CONST'

   arg_parser = arg_parser_t('synspec_to_specint SYNSPEC_FILE SPECINT_FILE', auto_help=.TRUE.)

   call arg_parser%define_option('file-type', OPT_REQUIRED_ARG, short_name='t', &
      usage='--file-type=TYPE', description='SYNSPEC file type ( flux | intensity )')
   call arg_parser%define_option('limb-law', OPT_REQUIRED_ARG, &
      usage='--limb-law=LAW', description='limb-darkening law ( CONST | LINEAR | SQRT | QUAD | CLARET )')
   call arg_parser%define_option('mu-min', OPT_REQUIRED_ARG, &
      usage='--mu-min=MIN', description='minimum mu value')
   call arg_parser%define_option('n-mu', OPT_REQUIRED_ARG, &
      usage='--n-mu=N', description='number of mu values')
   call arg_parser%define_option('label', OPT_REQUIRED_ARG, short_name='l', &
      usage='--label=NAME:VALUE', description='photospheric parameter name/value')

   call arg_parser%parse(arg_proc, opt_proc)

   if (.NOT. ALLOCATED(synspec_file_name)) call print_summary()
   if (.NOT. ALLOCATED(specint_file_name)) call print_summary()

   ! Create the specint

   select case(file_type)

   case('flux')

      call create_flux_specint(synspec_file_name, specint)

   case('intensity')

      if (.NOT. ALLOCATED(mu_min)) then
         @:STOP('--file-type choice requires --mu-min')
      end if

      if (.NOT. ALLOCATED(n_mu)) then
         @:STOP('--file-type choice requires --n_mu')
      end if

      call create_intensity_specint(synspec_file_name, limb_law, mu_min, n_mu, specint)

   case default

      @:STOP('invalid --file-type')

   end select

   ! Write the output file

   hdf5io = hdf5io_t(specint_file_name, CREATE_FILE)

   call specint%write(hdf5io)

   hdf5io_labels = hdf5io_t(hdf5io, 'labels')

   if (ALLOCATED(labels)) then

      do j = 1, SIZE(labels)

         call parse_name_value(labels(j), name, value, stat)
         if (stat /= STAT_OK) then
            @:STOP('invalid --label')
         end if

         call hdf5io_labels%write_attr(name, value)
      end do

   end if

   call hdf5io_labels%final()

   call hdf5io%final()

   ! Finish

contains

   subroutine arg_proc(a, value)

      integer, intent(in)      :: a
      character(*), intent(in) :: value

      select case(a)
      case(1)
         synspec_file_name = value
      case(2)
         specint_file_name = value
      case default
         call print_summary()
      end select

   end subroutine arg_proc

   !****

   subroutine opt_proc(name, value)

      character(*), intent(in) :: name
      character(*), intent(in) :: value

      integer :: stat

      stat = STAT_OK

      select case(name)
      case('file-type')
         file_type = value
      case('limb-law')
         limb_law = value
      case('mu-min')
         call parse_value(value, mu_min, stat)
      case('n-mu')
         call parse_value(value, n_mu, stat)
      case('label')
         call append_string(labels, value)
      case('help')
         call print_summary()
      case default
         @:ABORT('invalid option name')
      end select

      if (stat /= STAT_OK) then
         @:STOP('invalid --'//name)
      end if

   end subroutine opt_proc

   !****

   subroutine print_summary()

      call arg_parser%print_summary()
      @:STOP()

   end subroutine print_summary

   !****

   subroutine create_intensity_specint(synspec_file_name, limb_law, mu_min, n_mu, specint)

      character(*), intent(in)          :: synspec_file_name
      character(*), intent(in)          :: limb_law
      real(RD), intent(in)              :: mu_min
      integer, intent(in)               :: n_mu
      type(limb_specint_t), intent(out) :: specint

      type(limb_t)          :: limb
      real(RD), allocatable :: mu(:)
      integer               :: j
      real(RD), allocatable :: lam(:)
      real(RD), allocatable :: I(:,:)

      ! Set up the limb-darkening law & angle axis

      limb = limb_t(limb_law)

      mu = [((mu_min*(n_mu-j) + 1._RD*(j-1))/(n_mu-1), j=1,n_mu)]

      ! Read the intensity data

      call read_intensity_data(synspec_file_name, n_mu, lam, I)

      ! Create the specint

      specint = limb_specint_t(I, mu, tab_range_t(lam), limb, precise=.FALSE.)

      ! Finish

      return

   end subroutine create_intensity_specint

   !****

   subroutine create_flux_specint(synspec_file_name, specint)

      character(*), intent(in)          :: synspec_file_name
      type(limb_specint_t), intent(out) :: specint

      type(limb_t)          :: limb
      real(RD), allocatable :: lam(:)
      real(RD), allocatable :: I(:,:)
      integer               :: n_lam

      ! Set up the limb-darkening law & angle axis

      limb = limb_t('CONST')

      ! Read the flux data

      call read_flux_data(synspec_file_name, lam, I)

      ! Create the specint

      n_lam = SIZE(lam)

      specint = limb_specint_t(I, [1._RD], tab_range_t(lam), limb, precise=.FALSE.)

      ! Finish

      return

   end subroutine create_flux_specint

   !****

   subroutine read_intensity_data(synspec_file_name, n_mu, lam, I)

      character(*), intent(in)           :: synspec_file_name
      integer, intent(in)                :: n_mu
      real(RD), allocatable, intent(out) :: lam(:)
      real(RD), allocatable, intent(out) :: I(:,:)

      character(LEN=11) :: header
      character(LEN=11) :: form
      integer           :: unit
      real(RD)          :: H
      integer           :: d_lam
      integer           :: n_lam

      ! Determine the format of the input file

      open(NEWUNIT=unit, FILE=synspec_file_name, STATUS='OLD', FORM='UNFORMATTED')
      read(unit) header
      close(unit)

      if (header == 'SYNSPEC INT') then
         form = 'UNFORMATTED'
      else
         form = 'FORMATTED'
      end if

      ! Open the input file

      open(NEWUNIT=unit, FILE=synspec_file_name, STATUS='OLD', FORM=form)

      if (form == 'UNFORMATTED') then
         read(unit) header
      end if

      ! Read in the wavelength and intensity data

      d_lam = 1024

      allocate(lam(d_lam))
      allocate(I(n_mu,d_lam))

      n_lam = 0

      read_loop : do

         n_lam = n_lam + 1

         ! If necessary, expand arrays

         if(n_lam > d_lam) then
            d_lam = d_lam*2
            call reallocate(lam, [d_lam])
            call reallocate(I, [n_mu,d_lam])
         endif

         ! Read a block of data

         select case(form)
         case('UNFORMATTED')
            read(unit, END=100) lam(n_lam), H, I(:,n_lam)
         case('FORMATTED')
            read(unit, *, END=100) lam(n_lam), H
            read(unit,*) I(:,n_lam)
         end select

         ! Check for NaN intensities

         if (ANY(IEEE_IS_NAN(I(:,n_lam)))) then
            n_lam = n_lam - 1
            cycle read_loop
         end if

         ! Fix negative intensities

         I(:,n_lam) = MAX(I(:,n_lam), 0._RD)

         ! Reverse order

         I(:,n_lam) = I(n_mu:1:-1,n_lam)

         ! Convert from to ergs/s/cm**2/Hz/sr to ergs/s/cm**2/Angstrom/sr

         I(:,n_lam) = I(:,n_lam)*C_LIGHT/(lam(n_lam)*1E-8_RD)**2*1E-8_RD

      end do read_loop

100   continue

      close(unit)

      n_lam = n_lam - 1
      d_lam = n_lam

      call reallocate(lam, [d_lam])
      call reallocate(I, [n_mu,d_lam])

      write(OUTPUT_UNIT, *) 'n_lam (as read) :', n_lam

      ! Process the data

      call process_data(lam, I)

      ! Finish

      return

   end subroutine read_intensity_data

   !****

   subroutine read_flux_data(synspec_file_name, lam, I)

      character(*), intent(in)           :: synspec_file_name
      real(RD), allocatable, intent(out) :: lam(:)
      real(RD), allocatable, intent(out) :: I(:,:)

      character(LEN=11) :: header
      character(LEN=11) :: form
      integer           :: unit
      integer           :: d_lam
      integer           :: n_lam
      real(RD)          :: H

      ! Determine the format of the input file

      open(NEWUNIT=unit, FILE=synspec_file_name, STATUS='OLD', FORM='UNFORMATTED')
      read(unit) header
      close(unit)

      if (header == 'SYNSPEC FLX') then
         form = 'UNFORMATTED'
      else
         form = 'FORMATTED'
      end if

      ! Open the input file

      open(NEWUNIT=unit, FILE=synspec_file_name, STATUS='OLD', FORM=form)

      if (form == 'UNFORMATTED') then
         read(unit) header
      end if

      ! Read in the wavelength and flux

      d_lam = 1024

      allocate(lam(d_lam))
      allocate(I(1,d_lam))

      n_lam = 0

      read_loop : do

         n_lam = n_lam + 1

         ! If necessary, expand arrays

         if(n_lam > d_lam) then
            d_lam = d_lam*2
            call reallocate(lam, [d_lam])
            call reallocate(I, [1,d_lam])
         endif

         ! Read a block of data

         select case(form)
         case('UNFORMATTED')
            read(unit, END=100) lam(n_lam), H
         case('FORMATTED')
            read(unit, *, END=100) lam(n_lam), H
         end select

         ! Check for NaN fluxes

         if (IEEE_IS_NAN(H)) then
            n_lam = n_lam - 1
            cycle read_loop
         end if

         ! Fix negative fluxes

         H = MAX(H, 0._RD)

         ! Convert from Eddington flux to equivalent intensity in ergs/s/cm**2/Angstrom/sr

         I(1,n_lam) = 4._RD*H

      end do read_loop

100   continue

      close(unit)

      n_lam = n_lam - 1
      d_lam = n_lam

      call reallocate(lam, [d_lam])
      call reallocate(I, [1,d_lam])

      write(OUTPUT_UNIT, *) 'n_lam (as read) :', n_lam

      ! Process the data

      call process_data(lam, I)

      ! Finish

      return

   end subroutine read_flux_data

   !****

   subroutine process_data(lam, I)

      real(RD), allocatable, intent(inout) :: lam(:)
      real(RD), allocatable, intent(inout) :: I(:,:)

      integer :: ind(SIZE(lam))
      integer :: d_lam
      integer :: n_lam
      integer :: i_lam
      integer :: n_dup

      ! Sort the data by wavelength

      ind = sort_indices(lam)

      lam = lam(ind)
      I = I(:,ind)

      ! Merge duplicate points

      n_lam = 1
      d_lam = SIZE(lam)

      n_dup = 0

      merge_loop : do i_lam = 2,d_lam

         if(lam(i_lam) == lam(n_lam)) then

            I(:,n_lam) = I(:,n_lam) + I(:,i_lam)
            n_dup = n_dup + 1

         else

            if(n_dup > 0) then

               I(:,n_lam) = I(:,n_lam)/(n_dup + 1)
               n_dup = 0

            endif

            n_lam = n_lam + 1

            lam(n_lam) = lam(i_lam)
            I(:,n_lam) = I(:,i_lam)

         endif

      end do merge_loop

      if(n_dup > 0) then
         I(:,n_lam) = I(:,n_lam)/(n_dup + 1)
      endif

      ! Convert sampled intensities to averaged intensities

      lam = lam(1:n_lam)
      I = 0.5_RD*(I(:,1:n_lam-1) + I(:,2:n_lam))

      write(OUTPUT_UNIT, *) 'n_lam (merged)  :', n_lam
      write(OUTPUT_UNIT, *) 'lam_min (read)  :', lam(1)
      write(OUTPUT_UNIT, *) 'lam_max (read)  :', lam(n_lam)

      ! Finish

      return

   end subroutine process_data

end program synspec_to_specint
