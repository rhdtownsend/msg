! Submodule : indexer_construct_sm
! Purpose   : Constructor routines for indexer_t
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

submodule (indexer_m) indexer_construct_sm

   ! No implicit typing

   implicit none (type, external)

   ! Procedures

contains

   module procedure indexer_t_map_

      logical :: vert_mask(SIZE(v_lin_seq))

      ! Construct indexer from the shape and the sequence-to-linear
      ! vertex map

      @:ASSERT_DEBUG(ALL(shape > 0), 'invalid shape')

      ! Generate the vertex and cell index maps

      call generate_vert_maps_(shape, v_lin_seq, indexer%vert_lin_seq, indexer%vert_seq_lin)
      call generate_cell_maps_(shape, v_lin_seq, indexer%cell_lin_seq, indexer%cell_seq_lin)

      ! Set up the other components

      indexer%shape = shape
      indexer%rank = SIZE(shape)

      indexer%n_vert = PRODUCT(shape)
      indexer%n_vert_seq = SIZE(indexer%vert_lin_seq)

      indexer%n_cell = PRODUCT(shape-1)
      indexer%n_cell_seq = SIZE(indexer%cell_lin_seq)

      ! Finish

      return

   end procedure indexer_t_map_

   !****

   module procedure generate_vert_maps_

      integer :: n_vert
      integer :: n_vert_seq
      integer :: v_seq

      ! Generate vertex index maps:
      !
      !   vert_lin_seq(v_seq) -> v_lin
      !   vert_seq_lin(v_seq) -> v_seq
      !
      ! vert_lin_seq is directly copied from v_lin_seq. Currently,
      ! the code works fine if the entries in v_lin_seq are not
      ! monotonic increasing. However, this is a bit of a code
      ! smell; shouldn't sequential indices satisft
      ! vert_lin_seq(i+1) > vert_lin_seq(i)?

      n_vert = PRODUCT(shape)
      n_vert_seq = SIZE(v_lin_seq)

      @:ASSERT_DEBUG(MINVAL(v_lin_seq) >= 1, 'invalid v_lin_seq')
      @:ASSERT_DEBUG(MAXVAL(v_lin_seq) <= n_vert, 'invalid v_lin_seq')

      vert_lin_seq = v_lin_seq

      allocate(vert_seq_lin(n_vert))

      vert_seq_lin = NULL_NODE
      vert_seq_lin(vert_lin_seq) = [(v_seq, v_seq=1,n_vert_seq)]

      ! Finish

      return

   end procedure generate_vert_maps_

   !****

   module procedure generate_cell_maps_

      integer              :: n_cell
      type(indexer_t)      :: indexer
      logical, allocatable :: mask(:)
      integer              :: c_lin
      integer              :: c_vec(SIZE(shape))
      integer              :: i
      integer              :: v_vec(SIZE(shape))
      integer              :: v_lin
      integer              :: v_seq
      integer              :: n_cell_seq
      integer              :: c_seq

      ! Generate cell index maps:
      !
      !   indexer%cell_lin_seq(c_seq) -> c_lin
      !   indexer%cell_seq_lin(c_seq) -> c_seq
      !
      ! Unlike the case with the vertex index maps, cell_lin_seq is
      ! monotonic-increasing

      n_cell = PRODUCT(shape-1)

      ! Create a bootstrap indexer with sufficient information to
      ! allow cell_vector() and vert_*() to work

      call generate_vert_maps_(shape, v_lin_seq, indexer%vert_lin_seq, indexer%vert_seq_lin)

      indexer%shape = shape
      indexer%rank = SIZE(shape)

      indexer%n_vert = PRODUCT(shape)
      indexer%n_vert_seq = SIZE(indexer%vert_lin_seq)

      indexer%n_cell = n_cell

      ! Set up a mask for which cells have all corner vertices
      ! defined

      allocate(mask(n_cell))

      mask = .TRUE.

      cell_loop: do c_lin = 1, n_cell

         c_vec = indexer%cell_vector(c_lin)

         do i = 1, 2**indexer%rank

            v_vec = c_vec + indexer%offset_vector(i, 2)
            @:ASSERT_DEBUG(ALL(v_vec >= 1 .AND. v_vec <= indexer%shape), 'out-of-bounds v_vec')

            v_lin = indexer%vert_linear(v_vec)
            v_seq = indexer%vert_sequence(v_lin)

            if (v_seq == NULL_NODE) then
               mask(c_lin) = .FALSE.
               cycle cell_loop
            end if

         end do

      end do cell_loop

      n_cell_seq = COUNT(mask)

      ! Now generate the cell index maps

      cell_lin_seq = PACK([(c_lin, c_lin=1,n_cell)], MASK=mask)

      allocate(cell_seq_lin(n_cell))

      cell_seq_lin = NULL_NODE
      cell_seq_lin(cell_lin_seq) = [(c_seq, c_seq=1,n_cell_seq)]

      ! Finish

      return

   end procedure generate_cell_maps_

end submodule indexer_construct_sm
