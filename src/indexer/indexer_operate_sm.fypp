! Submodule : indexer_operate_sm
! Purpose   : Operation routines for indexer_t
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

submodule (indexer_m) indexer_operate_sm

   ! No implicit typing

   implicit none (type, external)

   ! Procedures

contains

   module procedure subset

      logical              :: vert_mask_(self%n_vert_seq)
      integer              :: v_seq
      integer              :: v_lin
      integer              :: v_vec(self%rank)
      integer, allocatable :: v_lin_seq(:)
      integer, allocatable :: shape_new(:)
      logical              :: dim_mask_(self%rank)
      integer              :: rank_new
      type(indexer_t)      :: indexer
      integer, allocatable :: v_vec_new(:)

      @:CHECK_BOUNDS(SIZE(i_min), self%rank)
      @:CHECK_BOUNDS(SIZE(i_max), self%rank)

      if (PRESENT(vert_mask)) then
         @:CHECK_BOUNDS(SIZE(vert_mask), self%n_vert_seq)
      end if

      if (PRESENT(dim_mask)) then
         @:CHECK_BOUNDS(SIZE(dim_mask), self%rank)
      end if

      ! Subset the indexer by retaining only those vertices with
      ! vector indices in the range defined by i_min and i_max (i.e.,
      ! i_min <= v_vec <= i_max). This potentially changes the rank,
      ! by removing degenerate dimensions
      !
      ! If vert_mask is present, it records which sequential vertices
      ! were retained. Likewise, if dim_mask is present, it records which
      ! dimensions were retained

      ! Build vert_mask_, indicating which sequential vertices are to
      ! be retained

      @:ASSERT_DEBUG(ALL(i_max >= i_min), 'invalid subset')

      vert_mask_ = .FALSE.

      do v_seq = 1, self%n_vert_seq

         v_lin = self%vert_linear(v_seq)
         v_vec = self%vert_vector(v_lin)

         if (ALL(v_vec >= i_min .AND. v_vec <= i_max)) then
            vert_mask_(v_seq) = .TRUE.
         end if

      end do

      ! Remove the non-retained vertices

      call self%remove_verts(.NOT. vert_mask_)

      ! Determine the new shape and rank

      dim_mask_ = i_max > i_min

      shape_new = PACK(i_max-i_min+1, dim_mask_)

      rank_new = SIZE(shape_new)

      ! Create a bootstrap indexer with sufficient information to
      ! allow vert_linear_vec_() to work

      indexer%shape = shape_new
      indexer%rank = rank_new

      ! Generate a revised v_lin_seq

      allocate(v_lin_seq(COUNT(vert_mask_)))

      allocate(v_vec_new(rank_new))

      do v_seq = 1, self%n_vert_seq

         v_lin = self%vert_linear(v_seq)
         v_vec = self%vert_vector(v_lin)

         v_vec_new = PACK(v_vec - i_min + 1, MASK=dim_mask_)

         v_lin_seq(v_seq) = indexer%vert_linear(v_vec_new)

      end do

      ! Update the indexer

      select type(self)
      type is(indexer_t)
         self = indexer_t(shape_new, v_lin_seq)
      class default
         @:ABORT('invalid type')
      end select

      ! If necessary, return vert_mask and/or dim_mask

      if (PRESENT(vert_mask)) vert_mask = vert_mask_
      if (PRESENT(dim_mask)) dim_mask = dim_mask_

      ! Finish

      return

   end procedure subset

   !****

   module procedure remove_verts

      integer :: v_lin_seq(COUNT(.NOT. vert_mask))

      ! Remove sequential vertices from the indexer, as selected by
      ! vert_mask

      v_lin_seq = PACK(self%vert_lin_seq, MASK=.NOT. vert_mask)

      select type(self)
      type is(indexer_t)
         self = indexer_t(self%shape, v_lin_seq)
      class default
         @:ABORT('invalid type')
      end select

      ! Finish

      return

   end procedure remove_verts

   !****

   module procedure find_orphans

      integer :: c_seq
      integer :: c_lin
      integer :: c_vec(self%rank)
      integer :: i
      integer :: v_vec(self%rank)
      integer :: v_lin
      integer :: v_seq

      @:CHECK_BOUNDS(SIZE(orphan_mask), self%n_vert_seq)

      ! Find orphaned vertices in the indexer (i.e., ones that aren't
      ! a corner of any cell), returning them in orphan_mask

      orphan_mask = .TRUE.

      do c_seq = 1, self%n_cell_seq

         c_lin = self%cell_linear(c_seq)
         c_vec = self%cell_vector(c_lin)

         do i = 1, 2**self%rank

            v_vec = c_vec + self%offset_vector(i, 2)
            @:ASSERT_DEBUG(ALL(v_vec >= 1 .AND. v_vec <= self%shape), 'out-of-bounds v_vec')

            v_lin = self%vert_linear(v_vec)
            v_seq = self%vert_sequence(v_lin)

            orphan_mask(v_seq) = .FALSE.

         end do

      end do

      ! Finish

      return

   end procedure find_orphans

end submodule indexer_operate_sm
