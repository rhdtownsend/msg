! Submodule : indexer_operate_sm
! Purpose   : Operation routines for indexer_t
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

submodule (indexer_m) indexer_operate_sm

   ! No implicit typing

   implicit none (type, external)

   ! Procedures

contains

   module procedure subset

      logical              :: vert_mask_(self%n_vert_seq)
      integer              :: v_seq
      integer              :: v_lin
      integer              :: v_vec(self%rank)
      integer, allocatable :: v_lin_seq(:)
      integer, allocatable :: shape_new(:)
      logical              :: dim_mask_(self%rank)
      integer              :: rank_new
      type(indexer_t)      :: indexer
      integer, allocatable :: v_vec_new(:)

      @:CHECK_BOUNDS(SIZE(i_min), self%rank)
      @:CHECK_BOUNDS(SIZE(i_max), self%rank)

      if (PRESENT(vert_mask)) then
         @:CHECK_BOUNDS(SIZE(vert_mask), self%n_vert_seq)
      end if

      if (PRESENT(dim_mask)) then
         @:CHECK_BOUNDS(SIZE(dim_mask), self%rank)
      end if

      ! Subset the indexer by retaining only those vertices with
      ! vector indices in the range defined by i_min and i_max (i.e.,
      ! i_min <= v_vec <= i_max). This potentially changes the rank,
      ! by removing degenerate dimensions
      !
      ! If vert_mask is present, it records which sequential vertices
      ! were retained. Likewise, if dim_mask is present, it records which
      ! dimensions were retained

      ! Build vert_mask_, indicating which sequential vertices are to
      ! be retained

      @:ASSERT_DEBUG(ALL(i_max >= i_min), 'invalid subset')

      vert_mask_ = .FALSE.

      do v_seq = 1, self%n_vert_seq

         v_lin = self%vert_linear(v_seq)
         v_vec = self%vert_vector(v_lin)

         if (ALL(v_vec >= i_min .AND. v_vec <= i_max)) then
            vert_mask_(v_seq) = .TRUE.
         end if

      end do

      ! Update the vertex index maps with the retained vertices
      ! (there's no point in updating the cell index maps yet)

      v_lin_seq = PACK(self%vert_lin_seq, MASK=vert_mask_)

      call generate_vert_maps_(self%shape, v_lin_seq, self%vert_lin_seq, self%vert_seq_lin)

      self%n_vert_seq = SIZE(self%vert_lin_seq)

      ! Determine the new shape and rank

      dim_mask_ = i_max > i_min

      shape_new = PACK(i_max-i_min+1, dim_mask_)

      rank_new = SIZE(shape_new)

      ! Create a bootstrap indexer with sufficient information to
      ! allow vert_linear_vec_() to work

      indexer%shape = shape_new
      indexer%rank = rank_new

      ! Generate a revised v_lin_seq

      allocate(v_vec_new(rank_new))

      do v_seq = 1, self%n_vert_seq

         v_lin = self%vert_linear(v_seq)
         v_vec = self%vert_vector(v_lin)

         v_vec_new = PACK(v_vec - i_min + 1, MASK=dim_mask_)

         v_lin_seq(v_seq) = indexer%vert_linear(v_vec_new)

      end do

      ! Update the vertex and cell index maps

      call generate_vert_maps_(shape_new, v_lin_seq, self%vert_lin_seq, self%vert_seq_lin)
      call generate_cell_maps_(shape_new, v_lin_seq, self%cell_lin_seq, self%cell_seq_lin)

      ! Update the other components

      self%shape = shape_new
      self%rank = SIZE(shape_new)

      self%n_vert = PRODUCT(shape_new)
      self%n_vert_seq = SIZE(self%vert_lin_seq)

      self%n_cell = PRODUCT(shape_new-1)
      self%n_cell_seq = SIZE(self%cell_lin_seq)

      ! If necessary, return vert_mask and/or dim_mask

      if (PRESENT(vert_mask)) vert_mask = vert_mask_
      if (PRESENT(dim_mask)) dim_mask = dim_mask_

      ! Finish

      return

   end procedure subset

   !****

   module procedure remove_verts

      integer :: v_lin_seq(COUNT(.NOT. vert_mask))

      ! Remove sequential vertices from the indexer, as selected by
      ! vert_mask

      v_lin_seq = PACK(self%vert_lin_seq, MASK=.NOT. vert_mask)

      call generate_vert_maps_(self%shape, v_lin_seq, self%vert_lin_seq, self%vert_seq_lin)
      call generate_cell_maps_(self%shape, v_lin_seq, self%cell_lin_seq, self%cell_seq_lin)

      self%n_vert_seq = SIZE(self%vert_lin_seq)
      self%n_cell_seq = SIZE(self%cell_lin_seq)

      ! Finish

      return

   end procedure remove_verts

   !****

   module procedure find_orphans

      integer :: c_seq
      integer :: c_lin
      integer :: c_vec(self%rank)
      integer :: i
      integer :: v_vec(self%rank)
      integer :: v_lin
      integer :: v_seq

      @:CHECK_BOUNDS(SIZE(vert_mask), self%n_vert_seq)

      ! Find orphaned vertices in the indexer (i.e., ones that aren't
      ! a corner of any cell), returning them in vert_mask

      vert_mask = .TRUE.

      do c_seq = 1, self%n_cell_seq

         c_lin = self%cell_linear(c_seq)
         c_vec = self%cell_vector(c_lin)

         do i = 1, 2**self%rank

            v_vec = c_vec + self%offset_vector(i, 2)
            @:ASSERT_DEBUG(ALL(v_vec >= 1 .AND. v_vec <= self%shape), 'out-of-bounds v_vec')

            v_lin = self%vert_linear(v_vec)
            v_seq = self%vert_sequence(v_lin)

            vert_mask(v_seq) = .FALSE.

         end do

      end do

      ! Finish

      return

   end procedure find_orphans

end submodule indexer_operate_sm
