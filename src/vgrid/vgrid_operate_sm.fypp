! Submodule : vgrid_operate_sm
! Purpose   : Operation routines for vgrid_t
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

submodule (vgrid_m) vgrid_operate_sm

   ! No implicit typing

   implicit none (type, external)

   ! Procedures

contains

   module procedure subset

      integer                   :: i_min(self%rank)
      integer                   :: i_max(self%rank)
      integer                   :: r
      integer                   :: i
      real(RD)                  :: x
      type(indexer_t)           :: indexer
      logical                   :: dim_mask_(self%rank)
      type(axis_t), allocatable :: axes(:)

      @:CHECK_BOUNDS(SIZE(x_min), self%rank)
      @:CHECK_BOUNDS(SIZE(x_max), self%rank)

      if (PRESENT(dim_mask)) then
         @:CHECK_BOUNDS(SIZE(dim_mask), self%rank)
      end if

      ! Subset the vgrid by retaining only those vertices with
      ! coordinates in the range defined by x_min and x_max (i.e.,
      ! x_min <= x_vec <= x_max along each dimension). This
      ! potentially changes the rank, by removing degenerate
      ! dimensions
      !
      ! If vert_mask is present, it records which sequential vertices
      ! were retained. Likewise, if dim_mask is present, it records which
      ! dimensions were retained

      ! Determine the index range from the coordinate range

      @:ASSERT_DEBUG(ALL(x_max >= x_min), 'invalid subset')

      i_min = HUGE(0)
      i_max = -HUGE(0)

      do r = 1, self%rank

         do i = 1, self%shape(r)

            call self%axes(r)%fetch(i, x)

            if (x >= x_min(r)) i_min(r) = MIN(i_min(r), i)
            if (x <= x_max(r)) i_max(r) = MAX(i_max(r), i)

         end do

      end do

      ! Subset the indexer and axes

      indexer = self%indexer

      call indexer%subset(i_min, i_max, vert_mask, dim_mask_)

      axes = PACK(self%axes, MASK=dim_mask_)

      call axes%subset(PACK(i_min, MASK=dim_mask_), PACK(i_max, MASK=dim_mask_))

      ! Update the vgrid

      select type(self)
      type is(vgrid_t)
         self = vgrid_t_indexer_(axes, indexer)
      class default
         @:ABORT('invalid type')
      end select

      ! If necessary, return dim_mask

      if (PRESENT(dim_mask)) dim_mask = dim_mask_

      ! Finish

      return

   end procedure subset

   !****

   module procedure remove_verts

      ! Remove sequential vertices from the vgrid, as selected by
      ! vert_mask

      call self%indexer%remove_verts(vert_mask)

      ! Finish

      return

   end procedure remove_verts

   !****

   module procedure find_orphans

      ! Find orphaned vertices in the indexer (i.e., ones that aren't
      ! a corner of any cell), returning them in orphan_mask

      call self%indexer%find_orphans(orphan_mask)

   end procedure find_orphans

end submodule vgrid_operate_sm
