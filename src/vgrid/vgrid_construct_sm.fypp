! Submodule : vgrid_construct_sm
! Purpose   : Constructor routines for vgrid_t
!
! Copyright 2021-2022 Rich Townsend & The MSG Team
!
! This file is part of MSG. MSG is free software: you can redistribute
! it and/or modify it under the terms of the GNU General Public
! License as published by the Free Software Foundation, version 3.
!
! MSG is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

submodule (vgrid_m) vgrid_construct_sm

   ! No implicit typing

   implicit none (type, external)

   ! Procedures

contains

   module procedure vgrid_t_coords_

      integer              :: r
      real(RD)             :: x(SIZE(x_vecs, 2))
      type(axis_t)         :: axes(SIZE(x_vecs, 1))
      integer              :: shape(SIZE(x_vecs, 1))
      integer, allocatable :: v_lin_seq(:)

      @:CHECK_BOUNDS(SIZE(labels), SIZE(x_vecs, 1))

      ! Construct vgrid from the vertex coordinate list and axis
      ! labels

      ! Build the axes

      do r = 1, SIZE(x_vecs, 1)

         x = x_vecs(r,:)

         associate (u => unique_indices(x))
            axes(r) = axis_t(x(u), labels(r))
         end associate

         call axes(r)%get_n(shape(r))

      end do

      ! Set up the vertex sequence-to-linear index map

      v_lin_seq = vert_linear_(x_vecs, axes)

      ! Construct vgrid

      vgrid = vgrid_t_indexer_(axes, indexer_t(shape, v_lin_seq))

      ! Finish

      return

   end procedure vgrid_t_coords_

   !****

   module procedure vgrid_t_map_

      integer :: shape(SIZE(axes))

      ! Construct vgrid from the axes and sequence-to-linear index map

      call axes%get_n(shape)

      vgrid = vgrid_t_indexer_(axes, indexer_t(shape, v_lin_seq))

      ! Finish

      return

   end procedure vgrid_t_map_

   !****

   module procedure vgrid_t_indexer_

      integer              :: rank_axes
      integer              :: shape_axes(SIZE(axes))
      integer              :: rank_indexer
      integer, allocatable :: shape_indexer(:)

      ! Construct vgrid from the axes and indexer

      rank_axes = SIZE(axes)

      call axes%get_n(shape_axes)

      @:ASSERT_DEBUG(ALL(shape_axes > 1), 'grid has degenerate axes')

      call indexer%get_rank(rank_indexer)

      @:ASSERT_DEBUG(rank_indexer == rank_axes, 'mismatched ranks')

      allocate(shape_indexer(rank_indexer))
      call indexer%get_shape(shape_indexer)

      @:ASSERT_DEBUG(ALL(shape_indexer == shape_indexer), 'mismatched shape')

      vgrid%axes = axes
      vgrid%indexer = indexer

      vgrid%shape = shape_indexer
      vgrid%rank = rank_indexer

      ! Set up the per-vertex cache

      call setup_cache_(vgrid)

      ! Finish

      return

   end procedure vgrid_t_indexer_

   !****

   module procedure vgrid_t_mask_

      integer :: n_v_lin
      integer :: v_lin_seq(COUNT(mask))
      integer :: v_lin
      integer :: shape(SIZE(axes))

      ! Construct vgrid from the axes and occupancy mask. This is a
      ! compatibility constructor for grids read in the "old" (rev <=
      ! 2) format

      ! Set up the vertex sequence-to-linear index map

      n_v_lin = SIZE(mask)

      v_lin_seq = PACK([(v_lin, v_lin=1,n_v_lin)], MASK=mask)

      ! Construct vgrid

      call axes%get_n(shape)

      vgrid = vgrid_t_indexer_(axes, indexer_t(shape, v_lin_seq))

      ! Finish

      return

   end procedure vgrid_t_mask_

   !****

   function vert_linear_(x_vecs, axes) result(v_lin)

      real(RD), intent(in)     :: x_vecs(:,:)
      type(axis_t), intent(in) :: axes(:)
      integer                  :: v_lin(SIZE(x_vecs, 2))

      integer  :: rank
      integer  :: shape(SIZE(axes))
      integer  :: v_seq
      integer  :: r
      integer  :: p
      integer  :: i
      real(RD) :: x

      @:CHECK_BOUNDS(SIZE(x_vecs, 1), SIZE(axes))

      ! Generate a list of linear vertex indices from the vertex
      ! coordinate list

      ! Extract the grid shape

      rank = SIZE(axes)

      call axes%get_n(shape)

      ! Set up the indices

      do v_seq = 1, SIZE(x_vecs, 2)

         ! Determine the linear index of the vertex

         v_lin(v_seq) = 1
         p = 1

         do r = 1, rank

            call axes(r)%locate(x_vecs(r,v_seq), i)

            #:if DEBUG
               call axes(r)%fetch(i, x)
               @:ASSERT(x == x_vecs(r,v_seq), 'mismatched vertex position')
            #:endif

            v_lin(v_seq) = v_lin(v_seq) + (i-1)*p

            p = p*shape(r)

         end do

      end do

      ! Finish

      return

   end function vert_linear_

   !****

   subroutine setup_cache_(vgrid)

      type(vgrid_t), intent(inout) :: vgrid

      integer              :: n_vert_seq
      logical, allocatable :: orphan_mask(:)
      logical              :: warned
      integer              :: v_seq
      integer              :: v_lin
      integer              :: v_vec(vgrid%rank)
      integer              :: v_vec_i(vgrid%rank)
      integer              :: i
      logical              :: vert_mask(3**vgrid%rank)
      integer              :: r
      integer              :: j
      real(RD)             :: x(3)
      real(RD)             :: edge_deltas(2,vgrid%rank)

      ! For each sequential vertex, cache data to be used later by
      ! data_kernel_cubic_cached

      ! Find orphan vertices, so as to avoid caching them. At some
      ! point in the future, when a strict prohibition on orphanless
      ! grids is enacted, this shouldn't be necessary

      call vgrid%indexer%get_n_vert_seq(n_vert_seq)

      allocate(orphan_mask(n_vert_seq))
      call vgrid%indexer%find_orphans(orphan_mask)

      ! Loop over sequential vertices, caching data

      allocate(vgrid%vert_cache(3*vgrid%rank*2, n_vert_seq))

      warned = .FALSE.

      do v_seq = 1, n_vert_seq

         if (.NOT. orphan_mask(v_seq)) then

            v_lin = vgrid%indexer%vert_linear(v_seq)
            v_vec = vgrid%indexer%vert_vector(v_lin)

            ! Set up the vert_mask

            do i = 1, 3**vgrid%rank

               v_vec_i = v_vec - 1 + vgrid%indexer%offset_vector(i, 3)

               if (ALL(v_vec_i >= 1 .AND. v_vec_i <= vgrid%shape)) then

                  v_lin = vgrid%indexer%vert_linear(v_vec_i)

                  vert_mask(i) = vgrid%indexer%vert_sequence(v_lin) /= NULL_NODE

               else

                  vert_mask(i) = .FALSE.

               end if

            end do

            ! Set up edge_deltas

            do r = 1, vgrid%rank

               do j = 1, 3

                  i = v_vec(r) + j - 2

                  if (i < 1) then
                     x(j) = -HUGE(0._RD)
                  elseif (i > vgrid%shape(r)) then
                     x(j) = HUGE(0._RD)
                  else
                     call vgrid%axes(r)%fetch(i, x(j))
                  endif

               end do

               edge_deltas(:,r) = x(2:3) - x(1:2)

            end do

            ! Cache the data

            vgrid%vert_cache(:,v_seq) = vertex_cache_cubic(vgrid%rank, vert_mask, edge_deltas)

         else

            vgrid%vert_cache(:,v_seq) = 0._RD

            if (.NOT. warned) then
               write(OUTPUT_UNIT, *) 'vgrid has orphan vertices'
               warned = .TRUE.
            end if

         end if

      end do

      ! Finish

      return

   end subroutine setup_cache_

end submodule vgrid_construct_sm
